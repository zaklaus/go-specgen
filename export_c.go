package main

import (
	"fmt"
	"strings"
)

const (
	stdIncludes = `/* This file has been generated by go-specgen. */
#include <stdint.h>
#include <stdio.h>

`
)

func (ctx *Context) exportC() {
	// Output required includes
	fmt.Print(stdIncludes)
	/* for _, x := range ctx.Specs {
		fmt.Printf("struct %s;\n", x.Name)
	} */

	// Sort specs based on dependency graph
	specs := retrieveSortedSpecs(ctx.Specs)

	fmt.Println("")

	// Output specifications
	for _, spec := range specs {
		fmt.Printf("typedef struct tag%s {\n", strings.ToUpper(spec.Name))
		{
			for _, field := range spec.Fields {
				fmt.Printf("\t%s%s %s", convSpecTypeToCType(ctx, field.Type), retStarIfPtr(field.IsPointer), field.Name)

				if field.IsArray {
					fmt.Printf("[%d]", field.ArrayLen)
				}

				fmt.Print(";")

				if field.DocString != "" {
					fmt.Printf(" /* %s */", strings.TrimSpace(field.DocString))
				}

				fmt.Println("")
			}
		}
		fmt.Printf("} %s;\n\n", spec.Name)
	}
}

func retStarIfPtr(isPtr bool) string {
	if isPtr {
		return "*"
	}

	return ""
}

func convSpecTypeToCType(ctx *Context, typeName string) string {
	switch typeName {
	case "int8":
		return "int8_t"
	case "int16":
		return "int16_t"
	case "int32":
		return "int32_t"
	case "int64":
		return "int64_t"

	case "uint8":
		return "uint8_t"
	case "uint16":
		return "uint16_t"
	case "uint32":
		return "uint32_t"
	case "uint64":
		return "uint64_t"

	case "float32":
		return "float"

	case "float64":
		return "double"
	}

	for _, v := range ctx.Specs {
		if v.Name == typeName {
			//return fmt.Sprintf("struct tag%s", strings.ToUpper(typeName))
			return fmt.Sprintf("%s", typeName)
		}
	}

	return typeName
}

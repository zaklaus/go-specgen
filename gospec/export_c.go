/*
   Copyright 2019 Dominik Madar√°sz
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
       http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

package gospec

import (
	"fmt"
	"strings"
)

const (
	stdIncludes = `/* This file has been generated by go-specgen. */
#include <stdint.h>
#include <stdio.h>

`
)

// ExportC exports data to the C language format
func (ctx *Context) ExportC() {
	// Output required includes
	fmt.Print(stdIncludes)
	/* for _, x := range ctx.Specs {
		fmt.Printf("struct %s;\n", x.Name)
	} */

	// Sort specs based on dependency graph
	specs := retrieveSortedSpecs(ctx.Specs)

	fmt.Println("")

	// Output enums
	for _, enum := range ctx.Enums {
		fmt.Printf("typedef enum {\n")
		for i, field := range enum.Fields {
			if field.DocString != "" {
				field.DocString = " //" + field.DocString
			}
			if i != len(enum.Fields)-1 {
				fmt.Printf("\t%s,%s\n", field.Value, field.DocString)
			} else {
				fmt.Printf("\t%s%s\n", field.Value, field.DocString)
			}
		}
		fmt.Printf("} %s;\n\n", enum.Name)
	}

	fmt.Println("")

	// Output specifications
	for _, spec := range specs {
		if spec.DocString != "" {
			fmt.Printf("/* %s */", strings.TrimSpace(spec.DocString))
		}
		fmt.Printf("typedef struct tag%s {\n", strings.ToUpper(spec.Name))
		{
			for _, field := range spec.Fields {
				fmt.Printf("\t%s%s %s", convSpecTypeToCType(ctx, field.Type), retStarIfPtr(field), field.Name)

				if field.IsArray && field.ArrayLen != 0 {
					fmt.Printf("[%d]", field.ArrayLen)
				}

				fmt.Print(";")

				if field.DocString != "" {
					fmt.Printf(" /* %s */", strings.TrimSpace(field.DocString))
				}

				fmt.Println("")
			}
		}
		fmt.Printf("} %s;\n\n", spec.Name)
	}
}

func retStarIfPtr(field Field) string {
	if field.IsPointer || (field.IsArray && field.ArrayLen == 0) {
		return "*"
	}

	return ""
}

func convSpecTypeToCType(ctx *Context, typeName string) string {
	switch typeName {
	case "int8":
		return "int8_t"
	case "int16":
		return "int16_t"
	case "int32":
		return "int32_t"
	case "int64":
		return "int64_t"

	case "uint8":
		return "uint8_t"
	case "uint16":
		return "uint16_t"
	case "uint32":
		return "uint32_t"
	case "uint64":
		return "uint64_t"

	case "float32":
		return "float"

	case "float64":
		return "double"
	}

	for _, v := range ctx.Specs {
		if v.Name == typeName {
			//return fmt.Sprintf("struct tag%s", strings.ToUpper(typeName))
			return fmt.Sprintf("%s", typeName)
		}
	}

	return typeName
}
